# 数电时钟



毫秒级计时器

```verilog

module ms_timer(
input clk,
input inc,
input wire switch, // 1 为start， 0 为stop
input rst, // 复位，上升沿触发，异步
output reg [7:0] num, // 选择显示的数据，用parameter参数赋值
output reg [3:0] loc// 选择哪一个数码管位输出
    );
parameter  SEG_NUM0 = 8'b00000011,  // abcdefg dp
           SEG_NUM1 = 8'b10011111,
              SEG_NUM2 = 8'b00100101,
              SEG_NUM3 = 8'b00001101,
              SEG_NUM4 = 8'b10011001,
              SEG_NUM5 = 8'b01001001,
              SEG_NUM6 = 8'b01000001,
              SEG_NUM7 = 8'b00011111,
              SEG_NUM8 = 8'b00000001,
              SEG_NUM9 = 8'b00001001,
              SEGD_NUM0 = 8'b00000010,  // 秒单位，需要小数点 abcdefg dp
           SEGD_NUM1 = 8'b10011110,
              SEGD_NUM2 = 8'b00100100,
              SEGD_NUM3 = 8'b00001100,
              SEGD_NUM4 = 8'b10011000,
              SEGD_NUM5 = 8'b01001000,
              SEGD_NUM6 = 8'b01000000,
              SEGD_NUM7 = 8'b00011110,
              SEGD_NUM8 = 8'b00000000,
              SEGD_NUM9 = 8'b00001000;
 
// 位选        
parameter  DUAN_3 = 4'b0111,              
              DUAN_2 = 4'b1011,
              DUAN_1 = 4'b1101,
              DUAN_0 = 4'b1110;
               
reg [20:0] count = 0;
reg [3:0] ms1 = 0;   // 毫秒单位
reg [3:0] ms10 = 0; // 10毫秒单位
reg [3:0] ms100 = 0; // 100毫秒单位
reg [3:0] s1 = 0; // 1秒单位
 
reg [17:0] fenpin = 0;
reg clk_1ms = 0;
reg cen = 0;
integer fsm = 1; //判断状态,一开始为停止状态
always @(posedge clk) begin
       if(fenpin == 100000)
           fenpin <= 0;
        else 
           fenpin <= fenpin + 1'b1;
end
 
always @ (posedge clk) begin
   if(fenpin < 50000)
        clk_1ms  <= 0;
    else
        clk_1ms  <= 1;
end
// 扫描位选
always @ (posedge clk) begin
   count <= count + 1'b1; 
end
 
always @ (posedge clk_1ms or posedge rst) begin
if (rst) begin
fsm = 1;
cen = 0;
end
else begin
 case(fsm)
    0: begin // 在start的自加状态下   
        cen = 1;
        if(!switch)// 触发stop
         fsm = 1;
         else 
          fsm = 0;
        end
     1: begin  // stop状态
        cen = 0;
        if(switch) //触发start
         fsm = 0;
       else if(inc) 
         fsm = 2;
         else
         fsm = 1;
       end        
     2: begin    // inc函数
        cen = 1;
        fsm = 3;
         end
     3: begin
        cen = 0;
         if(inc)
         fsm = 3;
         else
         fsm = 1;
       end
 endcase
end
 
end
 
// 计时器加1，实现4个数字的加法
always @ (posedge clk_1ms) begin 
if(!rst) begin
if(cen) begin
case(ms1)
     4'b1001: ms1 <= 4'b0000;
     default:  ms1 <= ms1 + 1'b1;
     endcase
      
     case(ms10)
     4'b1001: begin
               if(ms1 == 4'b1001)
                 ms10 <= 4'b0000;
                 end
     default: begin
               if(ms1 == 4'b1001)
                 ms10 <= ms10 + 1'b1;
                 end
     endcase
      
     case(ms100)
     4'b1001: begin
               if(ms1 == 4'b1001 && ms10 == 4'b1001)
                 ms100 <= 4'b0000;
                 end
     default: begin
               if(ms1 == 4'b1001 && ms10 == 4'b1001)
                 ms100 <= ms100 + 1'b1;
                 end
     endcase
      
     case(s1)
     4'b1001: begin
               if(ms1 == 4'b1001 && ms10 == 4'b1001 && ms100 == 4'b1001)
                 s1 <= 4'b0000;
                 end
     default: begin
               if(ms1 == 4'b1001 && ms10 == 4'b1001 && ms100 == 4'b1001)
                 s1 <= s1 + 1'b1;
                 end
     endcase
end
end
//复位清零
else begin
ms1 <= 0;
ms100 <= 0;
ms10 <= 0;
s1 <= 0;
end
end
 
// 扫描显示,位选信号。扫描到对应数码管位就显示那一位数字
always @ (posedge clk) begin
  case(count[19:18])
  2'b00: begin
          loc <= DUAN_3;
             case(s1)
             4'b0000: num <= SEGD_NUM0;
             4'b0001: num <= SEGD_NUM1;
             4'b0010: num <= SEGD_NUM2;
             4'b0011: num <= SEGD_NUM3;
             4'b0100: num <= SEGD_NUM4;
             4'b0101: num <= SEGD_NUM5;
             4'b0110: num <= SEGD_NUM6;
             4'b0111: num <= SEGD_NUM7;
             4'b1000: num <= SEGD_NUM8;
             4'b1001: num <= SEGD_NUM9;
             endcase
            end
     
  2'b01: begin
          loc <= DUAN_2;
             case(ms100)
             4'b0000: num <= SEG_NUM0;
             4'b0001: num <= SEG_NUM1;
             4'b0010: num <= SEG_NUM2;
             4'b0011: num <= SEG_NUM3;
             4'b0100: num <= SEG_NUM4;
             4'b0101: num <= SEG_NUM5;
             4'b0110: num <= SEG_NUM6;
             4'b0111: num <= SEG_NUM7;
             4'b1000: num <= SEG_NUM8;
             4'b1001: num <= SEG_NUM9;
             endcase
            end
  2'b10: begin
          loc <= DUAN_1;
             case(ms10)
             4'b0000: num <= SEG_NUM0;
             4'b0001: num <= SEG_NUM1;
             4'b0010: num <= SEG_NUM2;
             4'b0011: num <= SEG_NUM3;
             4'b0100: num <= SEG_NUM4;
             4'b0101: num <= SEG_NUM5;
             4'b0110: num <= SEG_NUM6;
             4'b0111: num <= SEG_NUM7;
             4'b1000: num <= SEG_NUM8;
             4'b1001: num <= SEG_NUM9;
             endcase
            end
  2'b11: begin
          loc <= DUAN_0;
             case(ms1)
             4'b0000: num <= SEG_NUM0;
             4'b0001: num <= SEG_NUM1;
             4'b0010: num <= SEG_NUM2;
             4'b0011: num <= SEG_NUM3;
             4'b0100: num <= SEG_NUM4;
             4'b0101: num <= SEG_NUM5;
             4'b0110: num <= SEG_NUM6;
             4'b0111: num <= SEG_NUM7;
             4'b1000: num <= SEG_NUM8;
             4'b1001: num <= SEG_NUM9;
             endcase
            end
  endcase
 
end
    
endmodule
 
 
 
//test 使用代码

module ms_timer(
input clk,
input inc,
input wire switch, // 1 为start， 0 为stop
input rst, // 复位，上升沿触发，异步
output reg [7:0] num, // 选择显示的数据，用parameter参数赋值
output reg [3:0] loc// 选择哪一个数码管位输出
    );
parameter  SEG_NUM0 = 8'b00000011,  // abcdefg dp
           SEG_NUM1 = 8'b10011111,
              SEG_NUM2 = 8'b00100101,
              SEG_NUM3 = 8'b00001101,
              SEG_NUM4 = 8'b10011001,
              SEG_NUM5 = 8'b01001001,
              SEG_NUM6 = 8'b01000001,
              SEG_NUM7 = 8'b00011111,
              SEG_NUM8 = 8'b00000001,
              SEG_NUM9 = 8'b00001001,
              SEGD_NUM0 = 8'b00000010,  // 秒单位，需要小数点 abcdefg dp
           SEGD_NUM1 = 8'b10011110,
              SEGD_NUM2 = 8'b00100100,
              SEGD_NUM3 = 8'b00001100,
              SEGD_NUM4 = 8'b10011000,
              SEGD_NUM5 = 8'b01001000,
              SEGD_NUM6 = 8'b01000000,
              SEGD_NUM7 = 8'b00011110,
              SEGD_NUM8 = 8'b00000000,
              SEGD_NUM9 = 8'b00001000;
 
// 位选        
parameter  DUAN_3 = 4'b0111,              
              DUAN_2 = 4'b1011,
              DUAN_1 = 4'b1101,
              DUAN_0 = 4'b1110;
               
reg [20:0] count = 0;
reg [3:0] ms1 = 0;   // 毫秒单位
reg [3:0] ms10 = 0; // 10毫秒单位
reg [3:0] ms100 = 0; // 100毫秒单位
reg [3:0] s1 = 0; // 1秒单位
 
reg cen = 0;
integer fsm = 1; //判断状态,一开始为停止状态
 
// 扫描位选
always @ (posedge clk) begin
   count <= count + 1'b1; 
end
 
always @ (posedge clk or posedge rst) begin
if (rst) begin
fsm = 1;
cen = 0;
end
else begin
 case(fsm)
    0: begin // 在start的自加状态下   
        cen = 1;
        if(!switch)// 触发stop
         fsm = 1;
         else  
          fsm = 0;
        end
     1: begin  // stop状态
        cen = 0;
        if(switch) //触发start
         fsm = 0;
       else if(inc) 
         fsm = 2;
         else
         fsm = 1;
       end        
     2: begin
        cen = 1;
        fsm = 3;
         end
      3: begin
        cen = 0;
         if(inc)
         fsm = 3;
         else
         fsm = 1;
       end
 endcase
end
 
end
 
always @ (posedge clk) begin 
if(!rst) begin
if(cen) begin
case(ms1)
     4'b1001: ms1 <= 4'b0000;
     default:  ms1 <= ms1 + 1'b1;
     endcase
      
     case(ms10)
     4'b1001: begin
               if(ms1 == 4'b1001)
                 ms10 <= 4'b0000;
                 end
     default: begin
               if(ms1 == 4'b1001)
                 ms10 <= ms10 + 1'b1;
                 end
     endcase
      
     case(ms100)
     4'b1001: begin
               if(ms1 == 4'b1001 && ms10 == 4'b1001)
                 ms100 <= 4'b0000;
                 end
     default: begin
               if(ms1 == 4'b1001 && ms10 == 4'b1001)
                 ms100 <= ms100 + 1'b1;
                 end
     endcase
      
     case(s1)
     4'b1001: begin
               if(ms1 == 4'b1001 && ms10 == 4'b1001 && ms100 == 4'b1001)
                 s1 <= 4'b0000;
                 end
     default: begin
               if(ms1 == 4'b1001 && ms10 == 4'b1001 && ms100 == 4'b1001)
                 s1 <= s1 + 1'b1;
                 end
     endcase
end
end
 
else begin
ms1 <= 0;
ms100 <= 0;
ms10 <= 0;
s1 <= 0;
end
end
 
// 扫描显示
always @ (posedge clk) begin
  case(count[2:1])
  2'b00: begin
          loc <= DUAN_3;
             case(s1)
             4'b0000: num <= SEGD_NUM0;
             4'b0001: num <= SEGD_NUM1;
             4'b0010: num <= SEGD_NUM2;
             4'b0011: num <= SEGD_NUM3;
             4'b0100: num <= SEGD_NUM4;
             4'b0101: num <= SEGD_NUM5;
             4'b0110: num <= SEGD_NUM6;
             4'b0111: num <= SEGD_NUM7;
             4'b1000: num <= SEGD_NUM8;
             4'b1001: num <= SEGD_NUM9;
             endcase
            end
     
  2'b01: begin
          loc <= DUAN_2;
             case(ms100)
             4'b0000: num <= SEG_NUM0;
             4'b0001: num <= SEG_NUM1;
             4'b0010: num <= SEG_NUM2;
             4'b0011: num <= SEG_NUM3;
             4'b0100: num <= SEG_NUM4;
             4'b0101: num <= SEG_NUM5;
             4'b0110: num <= SEG_NUM6;
             4'b0111: num <= SEG_NUM7;
             4'b1000: num <= SEG_NUM8;
             4'b1001: num <= SEG_NUM9;
             endcase
            end
  2'b10: begin
          loc <= DUAN_1;
             case(ms10)
             4'b0000: num <= SEG_NUM0;
             4'b0001: num <= SEG_NUM1;
             4'b0010: num <= SEG_NUM2;
             4'b0011: num <= SEG_NUM3;
             4'b0100: num <= SEG_NUM4;
             4'b0101: num <= SEG_NUM5;
             4'b0110: num <= SEG_NUM6;
             4'b0111: num <= SEG_NUM7;
             4'b1000: num <= SEG_NUM8;
             4'b1001: num <= SEG_NUM9;
             endcase
            end
  2'b11: begin
          loc <= DUAN_0;
             case(ms1)
             4'b0000: num <= SEG_NUM0;
             4'b0001: num <= SEG_NUM1;
             4'b0010: num <= SEG_NUM2;
             4'b0011: num <= SEG_NUM3;
             4'b0100: num <= SEG_NUM4;
             4'b0101: num <= SEG_NUM5;
             4'b0110: num <= SEG_NUM6;
             4'b0111: num <= SEG_NUM7;
             4'b1000: num <= SEG_NUM8;
             4'b1001: num <= SEG_NUM9;
             endcase
            end
  endcase
 
end
    
endmodule

```



59秒级计时器

```verilog
module cnt59(clk,rst_n,dataout,en);
 
input clk,rst_n;
:] dataout;
:] en;//COM使能输出
 
:] dataout;//各段数据输出
:] en;
 
:] cnt_scan;//扫描频率计数器
:] dataout_buf;
 
wire clk1m;
wire clk1000;
wire clk1;
 
//产生时钟
,Gen_ClkDiv3.divdWIDTH=;//分频时钟
div Gen_ClkDiv3(.reset(rst_n),.clkin(clk1000),.clkout(clk1));//端口名称关联
 
always@(posedge clk or negedge  rst_n)
begin
    if(!rst_n)
        begin //低电平复位
            cnt_scan<=;
         end
    else
        begin
            cnt_scan<=cnt_scan+;
        end
end
 
always @(cnt_scan)//段码扫描频率
begin
  :])
      'b00 :
          en = 'b1110;
      'b01 :
          en = 'b1101;
      'b10 :
          en = 'b1011;
      'b11 :
          en = 'b0111;
      default :
          en = 'b1110;
    endcase
end
 
:] cnt1;
:] cnt2;
:] cnt3;
:] cnt4;
 
always@(posedge clk1 or negedge  rst_n)
begin
  if(!rst_n)
    begin
    cnt1 <= 'b0000;
    cnt2 <= 'b0000;
    cnt3 <= 'b0000;
    cnt4 <= 'b0000;
    end
    else
    begin
    cnt1 <= (cnt1<)? cnt1+'b1:4'd0;
    cnt2 <= (cnt2<)? (cnt1==)?cnt2+'b1:cnt2 : (cnt1==9)?4'd0:cnt2;
    cnt3 <= (cnt3<)? (cnt2== && cnt1==)?cnt3+'b1:cnt3 : (cnt2==5 && cnt1==9)?4'd0:cnt3;
    cnt4 <= (cnt4<)? (cnt3== && cnt2== && cnt1==)?cnt4+'b1:cnt4 : (cnt3==9 && cnt2==5 && cnt1==9)?4'd0:cnt4;
    end
end    
 
always@(en) //对应COM信号给出各段数据，段码
begin
    case(en)
        'b1110:
            dataout_buf<=cnt1;//输入将要显示的数字
        'b1101:
            dataout_buf<=cnt2;
        'b1011:
            dataout_buf<=cnt3;
        'b0111:
            dataout_buf<=cnt4;
        default:
            dataout_buf<=;
     endcase
end
 
always@(dataout_buf)
begin
    case(dataout_buf)  //将要显示的数字译成段码
        'b0000://0
            dataout='b0000_0011;
        'b0001://1
            dataout='b1001_1111;
        'b0010://2
            dataout='b0010_0101;
        'b0011://3
            dataout='b0000_1101;
        'b0100://4
            dataout='b1001_1001;
        'b0101://5
            dataout='b0100_1001;
        'b0110://6
            dataout='b0100_0001;
        'b0111://7
            dataout='b0001_1111;
        'b1000://8
            dataout='b0000_0001;
        'b1001://9
            dataout='b0000_1001;
       default://这里仅编译了0-9这几个数字
            dataout='b1111_1111;//全灭
     endcase
end
 
endmodule
```





倒计时，分模块代码

分频器

```verilog
module fre_div_1000(
    input clk,
    input rst,
output reg cout
);
 reg [8:0]count;//1000DIVIDER
 always@(posedge clk,posedge rst)
 if(rst==1) begin
 count<=0;
 cout<=0;
 end
 else
 if(count==499) begin
 cout<=~cout;
 count<=0;
 end
 else
 count<=count+1;
endmodule

```



计数器

```verilog
module Counter_sixty(
input clk,
input rst,
input up,//技术模式转换
output reg [5:0]cnt
 );
 
 //variation declaration
// reg state,state_next;//1 represents up
// reg c,c_next;//show wherther up?
 
 //state logic
 always@(posedge clk,posedge rst)
 if(rst)
 cnt<=0;
 else
 if(up)//高电平上升计数
 if(cnt==60)
 cnt<=0;
 else
 cnt<=cnt+1;
 else//下降计数
 if(cnt==0)
 cnt<=60;
 else
 cnt<=cnt-1;

endmodule

```



二进制转BCD转换器

```verilog
module Hex2BCD(
    input [5:0]HEX,
    output  [3:0]BCDH,
    output  [3:0]BCDL
);
 //variation declaration
 wire [7:0] A;
 wire [3:0] c1,c2,c3,c4,c5,c6,c7;
 wire [3:0] d1,d2,d3,d4,d5,d6,d7;
 
 assign A={2'b00,HEX};//standardize HEX
 assign d1={1'b0,A[7:5]};
 assign d2={c1[2:0],A[4]};
 assign d3={c2[2:0],A[3]};
 assign d4={c3[2:0],A[2]};
 assign d5={c4[2:0],A[1]};
 assign d6={1'b0,c1[3],c2[3],c3[3]};
 assign d7={c6[2:0],c4[3]};
 Converter m1(d1,c1);
 Converter m2(d2,c2);
 Converter m3(d3,c3);
 Converter m4(d4,c4);
 Converter m5(d5,c5);
 Converter m6(d6,c6);
 Converter m7(d7,c7);
 //output
 assign BCDL={c5[2:0],A[0]};
 assign BCDH={c7[2:0],c5[3]};
 
endmodule

module Converter(
input [3:0]in,
output reg [3:0]out
    );
	 always@(in)
	 case(in)
	 4'b0000:out<=4'b0000;
	 4'b0001:out<=4'b0001;
	 4'b0010:out<=4'b0010;
	 4'b0011:out<=4'b0011;
	 4'b0100:out<=4'b0100;
	 4'b0101:out<=4'b1000;
	 4'b0110:out<=4'b1001;
	 4'b0111:out<=4'b1010;
	 4'b1000:out<=4'b1011;
	 4'b1001:out<=4'b1100;
	 default: out<=4'b0000;
	 endcase
endmodule

```



controller

```verilog
module Controller(
    input clk,
    input rst,
    input [3:0]H,
    input [3:0]L,
    output reg [3:0]Q,
    output reg [7:0]AN
    );
    //variation declaration
    reg state;
    reg state_next;//state reg 0 or 1;o represent low,1 represent high
    reg [3:0]Q_next;
    reg [7:0]AN_next;
    
    //FSMD state
    always@(posedge clk,posedge rst)
    if(rst==1) begin
    state<=0;
    Q<=8'H00;
    AN<=8'Hff;//全1测试
    end
    else begin
    state<=state_next;
    AN<=AN_next;
    Q<=Q_next;
    end
    
    //next state logic & output logic
    always@*
    begin
    state_next<=state;
    case(state)
    0: begin
    Q_next<=L;//output equals low 
    AN_next<=8'b11111110;//turn on the 8th led//高电平选中数码管位数
    state_next<=1;//next stage is high
    end
    1: begin
    Q_next<=H;//output equals HIGH 
    AN_next<=8'b11111101;//turn on the 7th led
    state_next<=0;//next stage is LOW
    end
    default:begin
     Q_next<=L;//output equals low 
     AN_next<=8'b11111110;//turn on the 8th led
     state_next<=1;//next stage is high
     end
     endcase
     end
     
endmodule

```



解码器

```verilog
module Controller(
    input clk,
    input rst,
    input [3:0]H,
    input [3:0]L,
    output reg [3:0]Q,
    output reg [7:0]AN
    );
    //variation declaration
    reg state;
    reg state_next;//state reg 0 or 1;o represent low,1 represent high
    reg [3:0]Q_next;
    reg [7:0]AN_next;
    
    //FSMD state
    always@(posedge clk,posedge rst)
    if(rst==1) begin
    state<=0;
    Q<=8'H00;
    AN<=8'Hff;//全1测试
    end
    else begin
    state<=state_next;
    AN<=AN_next;
    Q<=Q_next;
    end
    
    //next state logic & output logic
    always@*
    begin
    state_next<=state;
    case(state)
    0: begin
    Q_next<=L;//output equals low 
    AN_next<=8'b11111110;//turn on the 8th led//高电平选中数码管位数
    state_next<=1;//next stage is high
    end
    1: begin
    Q_next<=H;//output equals HIGH 
    AN_next<=8'b11111101;//turn on the 7th led
    state_next<=0;//next stage is LOW
    end
    default:begin
     Q_next<=L;//output equals low 
     AN_next<=8'b11111110;//turn on the 8th led
     state_next<=1;//next stage is high
     end
     endcase
     end
     
endmodule

```



## 模块整合

```verilog
module Conjugate(
    input clk,
    input rst,
    input up,
    output  [7:0] SEG,
    output  [7:0] AN
    );
    
    //varuation declaration
    wire clk1,clk2,clk3;
    wire [5:0]HEX;
    wire [3:0]BCDH;
    wire [3:0]BCDL;
    wire [3:0]BCD;
////    wire [7:0]AN0;
//    wire [7:0]SEG0;
    
    //module declaration
    fre_div_1000 fre_div1(
    .clk(clk),
    .rst(rst),
    .cout(clk1)
    );//frequency divider 1
    fre_div_1000 fre_div2(
    .clk(clk1),
    .rst(rst),
    .cout(clk2)
    );//100hz
    fre_div_100 fre_div3(
    .clk(clk2),
    .rst(rst),
    .cout(clk3)
    );//1HZ
    
    Counter_sixty Counter(
    .clk(clk3),
    .rst(rst),
    .up(up), //up signal
    .cnt(HEX)
    );//60Counter
    
    Hex2BCD hex2bcd(
    .HEX(HEX),
    .BCDH(BCDH),
    .BCDL(BCDL)
    );//transform HEX to BCD
    
    Controller controller(
    .clk(clk2),
    .rst(rst),
    .H(BCDH),
    .L(BCDL),
    .Q(BCD),//check the signal
    .AN(AN)
    );//control module
    
    
    Decoder decoder(
    .BCD(BCD),
    .SEG(SEG)//output SEG
    );
    
    //output logic
 
    
endmodule

```

