# 单调栈算法总结



单调栈是一种特殊的栈，特殊之处在于栈内的元素都保持一个单调性。 

利用单调栈，可以找到从左/右遍历第一个比它小/大的元素的位置

举个例子：
假设有一个单调递增的栈 S和一组数列：a = {5, 3, 7, 4}用数组L[ i ] 表示第 i 个数向左遍历的第一个比它小的元素的位置。如何求L[ i ]？首先我们考虑一个朴素的算法，可以按顺序枚举每一个数，然后再依此向左遍历。但是当数列单调递减时，复杂度是严格的O(n^2)。此时我们便可以利用单调栈在O(n)的复杂度下实现。我们按顺序遍历数组，然后构造一个单调递增栈

(1). i = 1时，因栈为空，L[1] = 0，此时再将第一个元素的位置下标1存入栈中

此时栈中情况：

1

(2).i = 2时，因当前3小于栈顶元素对应的元素5，故将5弹出栈
此时栈为空
故L[2] = 0
然后将元素3对应的位置下标2存入栈中

此时栈中情况：

2

(3).i = 3时，因当前7大于栈顶元素对应的元素3，故
L[3] = S.top() = 2 (栈顶元素的值)

然后将元素7对应的下标3存入栈
此时栈中情况：

2 -> 3

(4).i = 4时，为保持单调递增的性质，应将栈顶元素3弹出
此时 L[4] = S.top() = 2;

然后将元素4对应的下标3存入栈
此时栈中情况：

3 -> 4

至此 算法结束
对应的结果：
a : 5 3 7 4
L : 0 0 2 2

总结：一个元素向左遍历的第一个比它小的数的位置就是将它插入单调栈时栈顶元素的值，若栈为空，则说明不存在这么一个数。然后将此元素的下标存入栈，就能类似迭代般地求解后面的元素



代码如下：

```c++
Stack<int> S;
for(int i=1 ;i<=n ;i++){
    while(S.size() && a[S.top()] >= a[i])
        S.pop();
    if(S.empty())     
        L[i] = 0;
    else         
        L[i] = S.top();
        S.push(i);
    }
```



这个例题我还没找到特别合适的，所以先放着吧

